#INCLUDE "TOPCONN.CH"
#INCLUDE "PROTHEUS.CH"                                                      


/*/{Protheus.doc} SB1SQLEmbed
Fonte utilizado para extrair dados dos produtos da tabelas SB1
@type function
@version  
@author Sistematizei / Júnior Plácido
@since 20/06/2021
@return return_type, return_description
/*/
User Function SB1SQLEmbed()

Local cAliasSB1 := GetNextAlias() //Declarei meu ALIAS
Local aCabec := {} //ARRAY DO CABEÇALHO
Local aDados := {} //ARRAY QUE ARMAZENARÁ OS DADOS
Local cPerg 	 := "TRPROD" //VARIÁVEL QUE ARMAZENA O NOME DO GRUPO DE PERGUNTAS

Local cStatus	//Se está bloqueado ou não

ValidPerg(cPerg)
//Função responsável por chamar a pergunta criada na função ValidaPerg, a variável PRIVATE cPerg, é passada.
Pergunte(cPerg,.T.)


//COMEÇO A MINHA CONSULTA SQL
BeginSql Alias cAliasSB1                                                 //SB1010 ou diferente
		SELECT B1_FILIAL,B1_COD, B1_DESC, B1_TIPO, B1_UM, B1_MSBLQL FROM %table:SB1% SB1 
		WHERE B1_FILIAL = %xFilial:SB1% AND B1_COD BETWEEN  %exp:(MV_PAR01)% AND %exp:(MV_PAR02)%  //FILTRO WHERE
		AND SB1.%notdel%  
EndSql //FINALIZO A MINHA QUERY


cQry := GetLastQuery()[2] //Pegando a Query, para jogar dentro de uma variável para ser exportada depois
Memowrite('SB1SQLEmbed.sql', cQry)

//CABEÇALHO
aCabec := {"FILIAL","CODIGO","DESCRICAO","TIPO","UNIDADEDEMEDIDA","STATUS"}

//Até que chegue ao final do arquivo, faça o que está dentro do laço de repetição, entre as linhas 34 e 38
While !(cAliasSB1)->(Eof())
	IIF((cAliasSB1)->B1_MSBLQL == "1",cStatus := "Bloqueado",cStatus:="Desbloqueado")

	aAdd(aDados,{B1_FILIAL, B1_COD, B1_DESC, B1_TIPO, B1_UM,cStatus})
	
	(cAliasSB1)->(dbSkip()) //PASSAR PARA O PRÓXIMO REGISTRO
enddo

//JOGO TODO CONTEÚDO DO ARRAY PARA O EXCEL
DlgtoExcel({{"ARRAY","Relatório de Produtos", aCabec, aDados}})
	                                          
(cAliasSB1)->(dbClosearea())	

return



/*/{Protheus.doc} ValidPerg
FUNÇÃO RESPONSÁVEL POR CRIAR AS PERGUNTAS NA SX1 
@type function
@author PLACIDO / SISTEMATIZEI
@since 24/06/2019
@version 1.0
@see Com a tecla Ctrl PRESSIONADA clique --> https://www.youtube.com/watch?v=vSiJxbiSt8E
/*/Static Function ValidPerg(cPerg)
	Local aArea  := SX1->(GetArea())
	Local aRegs := {}
	Local i,j

	aadd( aRegs, { cPerg,"01","Produto de ?","Produto de ?","Produto de ?","mv_ch1","C", 15,0,0,"G","","mv_par01","","","mv_par01"," ","",""," ","","","","","","","","","","","","","","","","","","SB1"          } )
	aadd( aRegs, { cPerg,"02","Produto ate ?","Produto ate ?","Produto ate ?","mv_ch2","C", 15,0,0,"G","","mv_par02","","","mv_par02"," ","",""," ","","","","","","","","","","","","","","","","","","SB1"       } )

	DbselectArea('SX1')
	SX1->(DBSETORDER(1))
	For i:= 1 To Len(aRegs)
		If ! SX1->(DBSEEK( AvKey(cPerg,"X1_GRUPO") +aRegs[i,2]) )
			Reclock('SX1', .T.) //FUnção utilizada para gravar dados em um arquivo/tabela
			FOR j:= 1 to SX1->( FCOUNT() )
				IF j <= Len(aRegs[i])
					FieldPut(j,aRegs[i,j])
				ENDIF
			Next j
			SX1->(MsUnlock())
		Endif
	Next i 
	RestArea(aArea) 
Return(cPerg)
